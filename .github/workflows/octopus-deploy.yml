name: Octopus deploy

permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch: {}
  # Run automatically after the CI workflow completes successfully on the main branch
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

jobs:
  create-release:
    runs-on: ubuntu-latest
    # Only run this job automatically when the triggering workflow (CI) completed successfully
    # For manual workflow_dispatch this job will still run.
    if: github.event_name != 'workflow_run' || (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')
    env:
      # Prefer repository secrets. Set these in GitHub: Settings > Secrets
      DOCKER_IMAGE: ${{ secrets.REPO_DOCKER_IMAGE }}
      IMAGE_TAG_INPUT: ${{ secrets.REPO_IMAGE_TAG }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_ACCOUNT_ID: ${{ secrets.ECR_ACCOUNT_ID }}
      # Octopus project slug configurable via repo variable (set in Settings > Variables)
      OCTOPUS_PROJECT_SLUG: ${{ vars.OCTOPUS_PROJECT_SLUG }}
      # Expose GitHub context into env variables for shell steps
      GITHUB_SHA: ${{ github.sha }}
      GITHUB_REF: ${{ github.ref }}
      GITHUB_RUN_ID: ${{ github.run_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set provenance environment
        run: |
          # Use job-level env values (safer for YAML parsing)
          echo "COMMIT=${GITHUB_SHA}" >> $GITHUB_ENV
          # derive branch name from GITHUB_REF
          BRANCH_NAME=$(echo "${GITHUB_REF}" | sed -e 's@^refs/heads/@@') || true
          echo "BRANCH=${BRANCH_NAME}" >> $GITHUB_ENV
          echo "BUILD_URL=${{ github.server_url }}/${{ github.repository }}/actions/runs/${GITHUB_RUN_ID}" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Validate image (local or ECR)
        id: validate-pull
        run: |
          set -euo pipefail

          # Resolve values in shell
          LOCAL_IMAGE="${DOCKER_IMAGE:-}"
          TARGET_NAME="${ECR_REPOSITORY}"
          IMAGE_TAG_VAL="${IMAGE_TAG_INPUT:-${COMMIT:-}}"

          REGISTRY="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

          if [ -n "$LOCAL_IMAGE" ]; then
            echo "Attempting to pull local image name: $LOCAL_IMAGE"
            if docker pull "$LOCAL_IMAGE"; then
              echo "pulled_local=true" >> $GITHUB_OUTPUT
              echo "Pulled $LOCAL_IMAGE successfully"
              exit 0
            else
              echo "Local image pull failed, will try ECR image"
            fi
          fi

          FULL_IMAGE="$REGISTRY/$TARGET_NAME:$IMAGE_TAG_VAL"
          echo "Attempting to pull ECR image $FULL_IMAGE"
          docker pull "$FULL_IMAGE"
          echo "pulled_local=false" >> $GITHUB_OUTPUT

      - name: Get image digest
        id: get-digest
        run: |
          set -euo pipefail
          IMAGE_TAG_VAL="${IMAGE_TAG_INPUT:-${COMMIT:-}}"
          REPO_NAME="${ECR_REPOSITORY}"
          DIGEST=""
          if command -v aws >/dev/null 2>&1; then
            DIGEST=$(aws ecr batch-get-image --repository-name "$REPO_NAME" --image-ids imageTag="$IMAGE_TAG_VAL" --query 'images[0].imageId.imageDigest' --output text 2>/dev/null || true)
          fi
          echo "image_digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Resolve Octopus ProjectId by slug
        id: resolve-project
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTOPUS_API_KEY }}
          OCTOPUS_SERVER: ${{ secrets.OCTOPUS_SERVER }}
        run: |
          set -euo pipefail
          # Use repository variable if set, otherwise fall back to rtm-test
          SLUG="${OCTOPUS_PROJECT_SLUG:-rtm-test}"
          PROJECT_ID=""
          if [ -n "${OCTOPUS_API_KEY:-}" ] && [ -n "${OCTOPUS_SERVER:-}" ]; then
            # Query projects and filter by slug. The API returns an array of projects.
            PROJECT_ID=$(curl -sS -H "X-Octopus-ApiKey: ${OCTOPUS_API_KEY}" "${OCTOPUS_SERVER}/api/projects/all" | jq -r --arg slug "$SLUG" '.[] | select(.Slug==$slug) | .Id' || true)
          fi
          PROJECT_ID=${PROJECT_ID:-}
          echo "project_id=$PROJECT_ID" >> $GITHUB_OUTPUT

      - name: Build Octopus release payload
        id: build-payload
        env:
          OCTOPUS_PROJECT_ID: ${{ secrets.OCTOPUS_PROJECT_ID }}
          RESOLVED_PROJECT_ID: ${{ steps.resolve-project.outputs.project_id }}
        run: |
          set -euo pipefail
          # If DOCKER_IMAGE not provided, try to compute the local image name from Maven (artifactId:version)
          if [ -z "${DOCKER_IMAGE:-}" ]; then
            ARTIFACT_ID=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.artifactId}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec || true)
            PROJECT_VERSION=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec || true)
            ARTIFACT_ID=${ARTIFACT_ID:-demo}
            PROJECT_VERSION=${PROJECT_VERSION:-${COMMIT}}
            LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"
          fi

          IMAGE_TAG_VAL="${IMAGE_TAG_INPUT:-${COMMIT:-}}"
          REGISTRY="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          IMAGE_DIGEST="${{ steps.get-digest.outputs.image_digest }}"
          COMMIT_ID="${COMMIT}"
          BRANCH_NAME="${BRANCH}"
          BUILD_URL_VAL="${BUILD_URL}"

          # Build JSON safely via printf to avoid YAML parsing issues
          # Prefer explicit OCTOPUS_PROJECT_ID secret; fall back to resolved project id by slug
          PROJECT_ID_TO_USE="${OCTOPUS_PROJECT_ID:-}${RESOLVED_PROJECT_ID:-}"
          # If both are set, prefer the explicit secret
          if [ -n "${OCTOPUS_PROJECT_ID:-}" ]; then
            PROJECT_ID_TO_USE="${OCTOPUS_PROJECT_ID}"
          fi

          printf '{"ProjectId":"%s","Version":"%s","SelectedPackages":[],"ReleaseNotes":"Created from CI (image pull validated)","Variables":{"ImageTag":"%s","ImageName":"%s","Registry":"%s","ImageDigest":"%s","Commit":"%s","Branch":"%s","BuildUrl":"%s"}}' "${PROJECT_ID_TO_USE}" "${IMAGE_TAG_VAL}" "${IMAGE_TAG_VAL}" "${ECR_REPOSITORY}" "${REGISTRY}" "${IMAGE_DIGEST}" "${COMMIT_ID}" "${BRANCH_NAME}" "${BUILD_URL_VAL}" > octopus_payload.json

          echo "payload_file=octopus_payload.json" >> $GITHUB_OUTPUT

      - name: Post Octopus release
        env:
          OCTOPUS_API_KEY: ${{ secrets.OCTOPUS_API_KEY }}
          OCTOPUS_SERVER: ${{ secrets.OCTOPUS_SERVER }}
          PAYLOAD_FILE: ${{ steps.build-payload.outputs.payload_file }}
        run: |
          set -euo pipefail
          if [ ! -f "${PAYLOAD_FILE}" ]; then
            echo "Payload file not found: ${PAYLOAD_FILE}"
            exit 1
          fi

          curl -sS -X POST "${OCTOPUS_SERVER}/api/releases" \
            -H "X-Octopus-ApiKey: ${OCTOPUS_API_KEY}" \
            -H "Content-Type: application/json" \
            --data-binary @"${PAYLOAD_FILE}"
