name: CI

# CI workflow: builds with Maven + Paketo buildpacks, uses GitHub OIDC to assume role,
# caches Maven, computes semantic version tags and pushes to Amazon ECR.

# Recommended action tags (use the latest stable major; pin to a full commit SHA for production):
# - actions/checkout: v4
# - actions/setup-java: v4
# - actions/cache: v4
# - aws-actions/configure-aws-credentials: v2 (recommended: pin to SHA)
# - aws-actions/amazon-ecr-login: v1 (recommended: pin to SHA)
#
# To pin to a SHA: fetch the commit SHA from the action repo's commits page and replace the tag,
# e.g. uses: actions/checkout@<sha>

permissions:
  id-token: write
  contents: read

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  # Configuration is read from repository variables and secrets instead of workflow_call inputs.
  # Recommended repository variables / secrets to set:
  # - REPO_DOCKER_IMAGE (repo variable, optional)
  # - REPO_IMAGE_NAME  (repo variable, optional)
  # - ECR_REPOSITORY   (secret)
  # - AWS_REGION       (secret)
  # - AWS_ROLE_TO_ASSUME (secret)

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      # Prefer repository secrets; set these in GitHub: Settings > Secrets
      DOCKER_IMAGE: ${{ secrets.REPO_DOCKER_IMAGE }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      ECR_ACCOUNT_ID: ${{ secrets.ECR_ACCOUNT_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'oracle'

      - name: Cache Maven local repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        run: |
          ./mvnw -B -DskipTests verify

      - name: Build image with Buildpacks (paketo)
        run: |
          ./mvnw -B -DskipTests spring-boot:build-image

      - name: Resolve project version
        id: version
        run: |
          projectVersion=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec)
          echo "projectVersion=$projectVersion" >> $GITHUB_OUTPUT
          if [[ "$projectVersion" == *"SNAPSHOT" ]]; then
            semver=${projectVersion//-SNAPSHOT/-dev}
          else
            semver=$projectVersion
          fi
          echo "semver=$semver" >> $GITHUB_OUTPUT
          echo "SEMVER=$semver" >> $GITHUB_ENV

      - name: Compute appendVersion
        id: append_version
        run: |
          appendVersion=$(echo $SEMVER | awk -F. -v OFS=. '{$NF += 1 ; print}')
          echo "appendVersion=$appendVersion" >> $GITHUB_OUTPUT
          echo "APPEND_VERSION=$appendVersion" >> $GITHUB_ENV

      - name: Resolve role ARN (expects AWS_ROLE_TO_ASSUME env to be a full ARN)
        id: resolve-role
        run: |
          if [[ "${AWS_ROLE_TO_ASSUME}" != arn:aws:iam::* ]]; then
            echo "ERROR: Please set AWS_ROLE_TO_ASSUME to a full role ARN (arn:aws:iam::123456789012:role/Name)" >&2
            exit 1
          fi
          echo "ROLE_ARN=${AWS_ROLE_TO_ASSUME}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials (assume role via OIDC)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ steps.resolve-role.outputs.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPOSITORY" --image-scanning-configuration scanOnPush=true

      - name: Tag and push to ECR (projectVersion, appendVersion, sha)
        run: |
          set -euo pipefail
          REGISTRY=${{ steps.login-ecr.outputs.registry }}
          REPO=${ECR_REPOSITORY}
          SHA=${{ github.sha }}
          PROJECT_VERSION=${{ steps.version.outputs.projectVersion }}
          APPEND=${{ steps.append_version.outputs.appendVersion }}

          # Determine local image name (prefer DOCKER_IMAGE repo variable). If not provided,
          # use the build name: artifactId:projectVersion (derived from Maven).
          LOCAL_IMAGE="${DOCKER_IMAGE:-}"
          if [ -z "$LOCAL_IMAGE" ]; then
            ARTIFACT_ID=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.artifactId}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec)
            # fallback to 'demo' if artifact lookup fails
            ARTIFACT_ID=${ARTIFACT_ID:-demo}
            LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"
            echo "No DOCKER_IMAGE provided; using computed local image: $LOCAL_IMAGE"
          fi

          # Target name = ECR repository (no separate IMAGE_NAME)
          TARGET_NAME="$REPO"

          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$PROJECT_VERSION"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$APPEND"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$SHA"

          docker push "$REGISTRY/$TARGET_NAME:$PROJECT_VERSION"
          docker push "$REGISTRY/$TARGET_NAME:$APPEND"
          docker push "$REGISTRY/$TARGET_NAME:$SHA"
        env:
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}

      - name: Optionally push latest on main
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          REGISTRY=${{ steps.login-ecr.outputs.registry }}
          REPO=${ECR_REPOSITORY}
          LOCAL_IMAGE="${DOCKER_IMAGE:-}"
          if [ -z "$LOCAL_IMAGE" ]; then
            # compute image name if not supplied
            ARTIFACT_ID=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.artifactId}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec || true)
            ARTIFACT_ID=${ARTIFACT_ID:-demo}
            PROJECT_VERSION=${{ steps.version.outputs.projectVersion }}
            LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"
          fi
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$REPO:latest"
          docker push "$REGISTRY/$REPO:latest"
        env:
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
