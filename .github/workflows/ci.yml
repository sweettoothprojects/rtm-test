name: RTM Sample App CI

# CI workflow: builds with Maven + Paketo buildpacks, uses GitHub OIDC to assume role,
# caches Maven, computes semantic version tags and pushes to Amazon ECR.

permissions:
  id-token: write
  contents: read

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      # Prefer repository secrets; set these in GitHub: Settings > Secrets
  # DOCKER_IMAGE is unused; remove to avoid confusion
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      ECR_ACCOUNT_ID: ${{ secrets.ECR_ACCOUNT_ID }}
      # Allow CI to include the Octopus project slug in the payload (optional repo var)
      OCTOPUS_PROJECT_SLUG: ${{ vars.OCTOPUS_PROJECT_SLUG }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'oracle'

      - name: Cache Maven local repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Maven clean install (bootstrap modules)
        run: |
          ./mvnw -B clean install -DskipTests -DskipIt -U

      - name: Build module image
        run: |
          # Determine the module to build from the project's artifactId
          ARTIFACT_ID=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.artifactId}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec)
          ./mvnw -B package -pl "${ARTIFACT_ID}" spring-boot:build-image -DskipTests -DskipIt

      - name: Resolve project version
        id: version
        run: |
          # Use Maven help:evaluate to reliably read project.version
          projectVersion=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "projectVersion=$projectVersion" >> $GITHUB_OUTPUT
          if [[ "$projectVersion" == *"SNAPSHOT" ]]; then
            semver=${projectVersion//-SNAPSHOT/-dev}
          else
            semver=$projectVersion
          fi
          echo "semver=$semver" >> $GITHUB_OUTPUT
          echo "SEMVER_VERSION=$semver" >> $GITHUB_ENV

      - name: Compute appendVersion
        id: append_version
        run: |
          appendVersion=$(echo $SEMVER_VERSION | awk -F. -v OFS=. '{$NF += 1 ; print}')
          echo "appendVersion=$appendVersion" >> $GITHUB_OUTPUT
          echo "APPEND_VERSION=$appendVersion" >> $GITHUB_ENV

      - name: Build Octopus payload
        run: |
          set -euo pipefail
          # Extract Maven coordinates for payload
          ARTIFACT_ID=$(./mvnw help:evaluate -Dexpression=project.artifactId -q -DforceStdout || true)
          PROJECT_VERSION=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout || true)
          GROUP_ID=$(./mvnw help:evaluate -Dexpression=project.groupId -q -DforceStdout || true)
          REGISTRY="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          REPO="${ECR_REPOSITORY}"
          BRANCH_NAME=$(echo "${GITHUB_REF}" | sed -e 's@^refs/heads/@@') || true

          printf '%s' "{\"ProjectId\":\"${OCTOPUS_PROJECT_SLUG:-}\",\"Version\":\"${PROJECT_VERSION}\",\"SelectedPackages\":[],\"ReleaseNotes\":\"Created from CI\",\"Variables\":{\"ImageTag\":\"${PROJECT_VERSION}\",\"ImageName\":\"${REPO}\",\"Registry\":\"${REGISTRY}\",\"Commit\":\"${GITHUB_SHA}\",\"Branch\":\"${BRANCH_NAME}\",\"BuildUrl\":\"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\",\"ProjectVersion\":\"${PROJECT_VERSION}\"},\"package_id\":\"${GROUP_ID}\"}" > octopus_payload.json

      - name: Upload Octopus payload
        uses: actions/upload-artifact@v4
        with:
          name: octopus-payload
          path: octopus_payload.json

      - name: Create and upload build-info
        run: |
          set -euo pipefail
          # create a small JSON with the tags we pushed
          PROJECT_VERSION=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout || true)
          echo "{\"projectVersion\":\"${PROJECT_VERSION}\",\"appendVersion\":\"${APPEND_VERSION:-}\",\"sha\":\"${GITHUB_SHA}\"}" > build-info.json
        # upload build info for downstream workflows
      - name: Upload build-info artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-info
          path: build-info.json

      - name: Resolve role ARN (expects AWS_ROLE_TO_ASSUME env to be a full ARN)
        id: resolve-role
        run: |
          if [[ "${AWS_ROLE_TO_ASSUME}" != arn:aws:iam::* ]]; then
            echo "ERROR: Please set AWS_ROLE_TO_ASSUME to a full role ARN (arn:aws:iam::123456789012:role/Name)" >&2
            exit 1
          fi
          echo "ROLE_ARN=${AWS_ROLE_TO_ASSUME}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials (assume role via OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.resolve-role.outputs.ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPOSITORY" --image-scanning-configuration scanOnPush=true

      - name: Tag and push to ECR (projectVersion, appendVersion, sha)
        run: |
          set -euo pipefail
          REGISTRY=${{ steps.login-ecr.outputs.registry }}
          REPO=${ECR_REPOSITORY}
          SHA=${{ github.sha }}
          PROJECT_VERSION=${{ steps.version.outputs.projectVersion }}
          APPEND=${{ steps.append_version.outputs.appendVersion }}

          # Determine local image name from Maven (artifactId:projectVersion)
          ARTIFACT_ID=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.artifactId}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec)
          LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"

          # Target name = ECR repository (no separate IMAGE_NAME)
          TARGET_NAME="$REPO"

          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$PROJECT_VERSION"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$APPEND"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$SHA"

          docker push "$REGISTRY/$TARGET_NAME:$PROJECT_VERSION"
          docker push "$REGISTRY/$TARGET_NAME:$APPEND"
          docker push "$REGISTRY/$TARGET_NAME:$SHA"
        # Use job-level env for ECR_REPOSITORY

      - name: Optionally push latest on main
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          REGISTRY=${{ steps.login-ecr.outputs.registry }}
          REPO=${ECR_REPOSITORY}
          # compute image name from Maven
          ARTIFACT_ID=$(./mvnw -q -Dexec.executable=echo -Dexec.args='${project.artifactId}' --non-recursive org.codehaus.mojo:exec-maven-plugin:3.1.0:exec || true)
          if [ -z "${ARTIFACT_ID:-}" ]; then
            echo "ERROR: Could not determine artifactId from Maven. Ensure mvnw is present and pom.xml defines artifactId."
            exit 1
          fi
          PROJECT_VERSION=${{ steps.version.outputs.projectVersion }}
          LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$REPO:latest"
          docker push "$REGISTRY/$REPO:latest"
        # Use job-level env for ECR_REPOSITORY
