name: RTM Sample App CI

# CI workflow: builds with Maven + Paketo buildpacks, uses GitHub OIDC to assume role,
# caches Maven, computes semantic version tags and pushes to Amazon ECR.

permissions:
  id-token: write
  contents: read

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      # Prefer repository secrets; set these in GitHub: Settings > Secrets
  # DOCKER_IMAGE is unused; remove to avoid confusion
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
      ECR_ACCOUNT_ID: ${{ secrets.ECR_ACCOUNT_ID }}
      # Allow CI to include the Octopus project slug in the payload (optional repo var)
      OCTOPUS_PROJECT_SLUG: ${{ vars.OCTOPUS_PROJECT_SLUG }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'oracle'

      - name: Cache Maven local repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Maven clean install (bootstrap modules)
        run: |
          ./mvnw -B clean install -DskipTests -DskipIt -U

      - name: Resolve Maven coordinates
        id: resolve-maven
        run: |
          set -euo pipefail
          ARTIFACT_ID=$(./mvnw help:evaluate -Dexpression=project.artifactId -q -DforceStdout || true)
          PROJECT_VERSION=$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout || true)
          GROUP_ID=$(./mvnw help:evaluate -Dexpression=project.groupId -q -DforceStdout || true)
          echo "artifact_id=${ARTIFACT_ID}" >> $GITHUB_OUTPUT
          echo "project_version=${PROJECT_VERSION}" >> $GITHUB_OUTPUT
          echo "group_id=${GROUP_ID}" >> $GITHUB_OUTPUT

      - name: Build module image
        run: |
          ARTIFACT_ID=${{ steps.resolve-maven.outputs.artifact_id }}
          # Build the module by artifactId (use :artifactId form) and also build required modules (-am)
          ./mvnw -B package -pl ":${ARTIFACT_ID}" -am spring-boot:build-image -DskipTests -DskipIt

      - name: Resolve project version
        id: version
        run: |
          # Use the project_version resolved earlier to avoid running mvnw multiple times
          projectVersion="${{ steps.resolve-maven.outputs.project_version }}"
          echo "projectVersion=$projectVersion" >> $GITHUB_OUTPUT
          if [[ "$projectVersion" == *"SNAPSHOT" ]]; then
            semver=${projectVersion//-SNAPSHOT/-dev}
          else
            semver=$projectVersion
          fi
          echo "semver=$semver" >> $GITHUB_OUTPUT
          echo "SEMVER_VERSION=$semver" >> $GITHUB_ENV

      - name: Build Octopus payload (create file)
        uses: finnp/create-file-action@master
        env:
          FILE_NAME: "octopus_payload.json"
          FILE_DATA: >
            {"ProjectId":"${{ vars.OCTOPUS_PROJECT_SLUG }}","Version":"${{ steps.resolve-maven.outputs.project_version }}","SelectedPackages":[],"ReleaseNotes":"Created from CI","Variables":{"ImageTag":"${{ steps.resolve-maven.outputs.project_version }}","ImageName":"${{ env.ECR_REPOSITORY }}","Registry":"${{ env.ECR_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com","Commit":"${{ github.sha }}","Branch":"${{ github.ref }}","BuildUrl":"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}","ProjectVersion":"${{ steps.resolve-maven.outputs.project_version }}"},"package_id":"${{ steps.resolve-maven.outputs.group_id }}"}

      - name: Upload Octopus payload
        uses: actions/upload-artifact@v4
        with:
          name: octopus-payload
          path: octopus_payload.json

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "$ECR_REPOSITORY" --image-scanning-configuration scanOnPush=true

      - name: Tag and push to ECR (projectVersion, sha)
        run: |
          set -euo pipefail
          REGISTRY=${{ steps.login-ecr.outputs.registry }}
          REPO=${ECR_REPOSITORY}
          SHA=${{ github.sha }}
          PROJECT_VERSION=${{ steps.version.outputs.projectVersion }}

          # Use resolved artifactId
          ARTIFACT_ID=${{ steps.resolve-maven.outputs.artifact_id }}
          LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"

          # Target name = ECR repository (no separate IMAGE_NAME)
          TARGET_NAME="$REPO"

          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$PROJECT_VERSION"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$TARGET_NAME:$SHA"

          docker push "$REGISTRY/$TARGET_NAME:$PROJECT_VERSION"
          docker push "$REGISTRY/$TARGET_NAME:$SHA"

      - name: Push latest on main branch
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          REGISTRY=${{ steps.login-ecr.outputs.registry }}
          REPO=${ECR_REPOSITORY}
          # use resolved artifactId
          ARTIFACT_ID=${{ steps.resolve-maven.outputs.artifact_id }}
          PROJECT_VERSION=${{ steps.version.outputs.projectVersion }}
          LOCAL_IMAGE="${ARTIFACT_ID}:${PROJECT_VERSION}"
          docker tag "$LOCAL_IMAGE" "$REGISTRY/$REPO:latest"
          docker push "$REGISTRY/$REPO:latest"
        # Use job-level env for ECR_REPOSITORY
